package info.blazey.wmp.mrjp.blang;

import info.blazey.wmp.mrjp.blang.BlangParser.program_return;

import java.util.HashMap;
import java.util.Map;

import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CharStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.TokenRewriteStream;
import org.antlr.runtime.tree.CommonTree;

/**
 * Blang programming language interpreter.
 * Github repository: https://github.com/blazeyo/Blang
 * 
 * @author Błażej Owczarczyk
 */
public class BlangProgramEvaluator {
	
	private static Map<String, Integer> variables;
	
	/**
	 * Executes Blang program.
	 * 
	 * @param program
	 * @return Program return value.
	 * @throws RecognitionException
	 */
	public static int execute(String program) throws RecognitionException {
		CharStream stream = new ANTLRStringStream(program);
		BlangLexer lexer = new BlangLexer(stream);
		TokenRewriteStream tokens = new TokenRewriteStream(lexer);
		BlangParser parser = new BlangParser(tokens);
		
		program_return programEvaluation = parser.program();
		CommonTree tree = (CommonTree) programEvaluation.getTree();
		
		variables = new HashMap<String, Integer>();
		
		return executeProgram(tree);
	}
	
	/**
	 * Executes program tree and returns the return statement expression value.
	 * 
	 * @param root Root of program tree (generated by BlangParser)
	 * @return Program return value.
	 */
	private static int executeProgram(CommonTree root) {
		executeTree(root);
		
		CommonTree returnStatement = (CommonTree) root.getChild(root.getChildCount() - 1);
		return evaluateExpression((CommonTree) returnStatement.getChild(0));
	}
	
	/**
	 * Executes all statements that are children of given node.
	 * 
	 * @param root Root node.
	 */
	private static void executeTree(CommonTree root) {
		for (int i = 0; i < root.getChildCount(); i++) {
			CommonTree c = (CommonTree) root.getChild(i);
			executeStatement(c);
		}
	}
	
	/**
	 * Executes a statement.
	 * 
	 * @param statement Statement root node.
	 */
	private static void executeStatement(CommonTree statement) {
		switch (statement.getToken().getType()) {
			case BlangParser.ASSIGN:
				String id = statement.getChild(0).getText();
				int value = evaluateExpression((CommonTree) statement.getChild(1));
				variables.put(id, value);
				break;
			case BlangParser.IF:
				int condition = evaluateExpression((CommonTree) statement.getChild(0));
				if (condition != 0) {
					executeTree((CommonTree) statement.getChild(1));
				} else if (statement.getChildCount() > 2) {
					executeTree((CommonTree) statement.getChild(2));
				}
				break;
			case BlangParser.WHILE:
				CommonTree conditionNode = (CommonTree) statement.getChild(0);
				while (evaluateExpression(conditionNode) != 0) {
					executeTree((CommonTree) statement.getChild(1));
				}
				break;
		}
	}
	
	/**
	 * Evaluates an expression recursively.
	 * 
	 * @param expression Expression tree root.
	 * @return Expression value.
	 */
	private static int evaluateExpression(CommonTree expression) {
		CommonTree op1 = (CommonTree) expression.getChild(0);
		CommonTree op2 = (CommonTree) expression.getChild(1);
		org.antlr.runtime.Token token = expression.getToken();
		
		switch (token.getType()) {
			case BlangParser.INTEGER:
				return Integer.parseInt(token.getText());
			case BlangParser.IDENT:
				if (variables.containsKey(token.getText())) {
					return variables.get(token.getText());
				} else {
					System.out.println("Warning: Undefined variable " + token.getText() + ". Assuming value 0.");
					return 0;
				}
			
			case BlangParser.PLUS:
				return evaluateExpression(op1) + evaluateExpression(op2);
			case BlangParser.MINUS:
				return evaluateExpression(op1) - evaluateExpression(op2);
			case BlangParser.MULT:
				return evaluateExpression(op1) * evaluateExpression(op2);
			case BlangParser.DIV:
				return evaluateExpression(op1) / evaluateExpression(op2);
			case BlangParser.MOD:
				return evaluateExpression(op1) % evaluateExpression(op2);
			case BlangParser.NEGATION:
				return -evaluateExpression(op1);
		}
		
		return 0;
	}
	
}
